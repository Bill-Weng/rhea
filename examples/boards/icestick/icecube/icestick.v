// File: icestick.v
// Generated by MyHDL 1.0dev
// Date: Tue Dec  1 07:02:17 2015


`timescale 1ns/10ps

module icestick (
    clock,
    led,
    pmod,
    uart_tx,
    uart_rx,
    uart_dtr,
    uart_rts
);
// This example is similar to the other examples in this directory but
// the LEDs are controlled externally via command packets sent from a
// host via the UART on the icestick.
// 
// Ports:
//   clock:
//   led:
//   pmod:
//   uart_tx:
//   uart_rx:

input clock;
output [4:0] led;
reg [4:0] led;
output [7:0] pmod;
reg [7:0] pmod;
output uart_tx;
wire uart_tx;
input uart_rx;
input uart_dtr;
input uart_rts;

reg memmap_read;
reg [31:0] memmap_read_data;
reg [7:0] ledreg;
reg [7:0] tone;
reg glbl_tick_sec;
reg [27:0] memmap_mem_addr;
reg [31:0] memmap_write_data;
reg memmap_done;
reg memmap_write;
reg cmd_inst_ready;
reg cmd_inst_fbtx_full;
reg [3:0] cmd_inst_state;
reg cmd_inst_fbrx_rd;
reg [7:0] cmd_inst_bytemon;
wire cmd_inst_fbrx_rvld;
reg cmd_inst_fbtx_wr;
wire [31:0] cmd_inst_address;
wire [31:0] cmd_inst_data;
reg [3:0] cmd_inst_bb_per_addr;
reg cmd_inst_fbrx_empty;
wire cmd_inst_reset;
reg [7:0] cmd_inst_fbtx_wdata;
reg cmd_inst_error;
wire [7:0] cmd_inst_fbrx_rdata;
reg [5:0] cmd_inst_mmc_inst_tocnt;
reg [2:0] cmd_inst_mmc_inst_state;
reg uart_inst_baudce16;
reg uart_inst_tx;
wire uart_inst_rx;
reg uart_inst_baudce;
reg [7:0] uart_inst_instrx_fbusrx_wdata;
reg uart_inst_instrx_midbit;
reg [7:0] uart_inst_instrx_rxbyte;
reg uart_inst_instrx_fbusrx_wr;
reg uart_inst_instrx_rxd;
reg [3:0] uart_inst_instrx_bitcnt;
reg [1:0] uart_inst_instrx_state;
reg [3:0] uart_inst_instrx_mcnt;
reg uart_inst_instrx_rxinprog;
reg [7:0] uart_inst_insttx_txbyte;
reg uart_inst_insttx_fbustx_empty;
reg uart_inst_insttx_fbustx_rd;
reg [3:0] uart_inst_insttx_bitcnt;
reg [2:0] uart_inst_insttx_state;
wire [7:0] uart_inst_insttx_fbustx_rdata;
reg [10:0] uart_inst_instbaud_cnt;
reg [3:0] uart_inst_instbaud_cnt16;
reg [2:0] uart_inst_instrxfifo_nvacant;
reg uart_inst_instrxfifo_full;
reg [1:0] uart_inst_instrxfifo_addr;
wire uart_inst_instrxfifo_fbus_clear;
wire [2:0] uart_inst_instrxfifo_fbus_count;
reg [2:0] uart_inst_instrxfifo_ntenant;
reg [2:0] uart_inst_insttxfifo_nvacant;
reg [1:0] uart_inst_insttxfifo_addr;
wire uart_inst_insttxfifo_fbus_rvld;
wire uart_inst_insttxfifo_fbus_clear;
wire [2:0] uart_inst_insttxfifo_fbus_count;
reg [2:0] uart_inst_insttxfifo_ntenant;
reg [13:0] tick_inst_mscnt;
reg [9:0] tick_inst_seccnt;
reg tick_inst_g2_increment;

reg [7:0] cmd_inst_packet [0:12-1];
reg [7:0] uart_inst_instrxfifo_mem [0:4-1];
reg [7:0] uart_inst_insttxfifo_mem [0:4-1];
reg uart_inst_instsynctx_staps [0:2-1];
reg uart_inst_instsyncrx_staps [0:2-1];

assign cmd_inst_reset = 0;
assign uart_inst_instrxfifo_fbus_clear = 0;
assign uart_inst_insttxfifo_fbus_clear = 0;

assign cmd_inst_address[32-1:24] = cmd_inst_packet[2];
assign cmd_inst_address[24-1:16] = cmd_inst_packet[3];
assign cmd_inst_address[16-1:8] = cmd_inst_packet[4];
assign cmd_inst_address[8-1:0] = cmd_inst_packet[5];
assign cmd_inst_data[32-1:24] = cmd_inst_packet[8];
assign cmd_inst_data[24-1:16] = cmd_inst_packet[9];
assign cmd_inst_data[16-1:8] = cmd_inst_packet[10];
assign cmd_inst_data[8-1:0] = cmd_inst_packet[11];


always @(posedge clock) begin: ICESTICK_TICK_INST_G1_RTL_COUNT
    if (cmd_inst_reset == 1) begin
        tick_inst_mscnt <= 0;
    end
    else begin
        if (1) begin
            if (($signed({1'b0, tick_inst_mscnt}) == (12000 - 1))) begin
                tick_inst_mscnt <= 0;
            end
            else begin
                tick_inst_mscnt <= (tick_inst_mscnt + 1);
            end
        end
    end
end


always @(posedge clock) begin: ICESTICK_TICK_INST_G1_RTL_OVERFLOW
    if ((1 && ($signed({1'b0, tick_inst_mscnt}) == (12000 - 2)))) begin
        tick_inst_g2_increment <= 1'b1;
    end
    else begin
        tick_inst_g2_increment <= 1'b0;
    end
end


always @(posedge clock) begin: ICESTICK_TICK_INST_G2_RTL_COUNT
    if (cmd_inst_reset == 1) begin
        tick_inst_seccnt <= 0;
    end
    else begin
        if (tick_inst_g2_increment) begin
            if (($signed({1'b0, tick_inst_seccnt}) == (1000 - 1))) begin
                tick_inst_seccnt <= 0;
            end
            else begin
                tick_inst_seccnt <= (tick_inst_seccnt + 1);
            end
        end
    end
end


always @(posedge clock) begin: ICESTICK_TICK_INST_G2_RTL_OVERFLOW
    if ((tick_inst_g2_increment && ($signed({1'b0, tick_inst_seccnt}) == (1000 - 2)))) begin
        glbl_tick_sec <= 1'b1;
    end
    else begin
        glbl_tick_sec <= 1'b0;
    end
end


always @(posedge clock) begin: ICESTICK_UART_INST_INSTTXFIFO_GENS_0
    integer ii;
    if (cmd_inst_fbtx_wr) begin
        uart_inst_insttxfifo_mem[0] <= cmd_inst_fbtx_wdata;
        for (ii=1; ii<4; ii=ii+1) begin
            uart_inst_insttxfifo_mem[ii] <= uart_inst_insttxfifo_mem[(ii - 1)];
        end
    end
end



assign uart_inst_insttx_fbustx_rdata = uart_inst_insttxfifo_mem[uart_inst_insttxfifo_addr];



assign uart_inst_insttxfifo_fbus_rvld = uart_inst_insttx_fbustx_rd;


always @(posedge clock) begin: ICESTICK_UART_INST_INSTTXFIFO_GENS_3
    if (cmd_inst_reset == 1) begin
        cmd_inst_fbtx_full <= 0;
        uart_inst_insttx_fbustx_empty <= 1;
        uart_inst_insttxfifo_addr <= 0;
    end
    else begin
        if (uart_inst_insttxfifo_fbus_clear) begin
            uart_inst_insttxfifo_addr <= 0;
            uart_inst_insttx_fbustx_empty <= 1'b1;
            cmd_inst_fbtx_full <= 1'b0;
        end
        else if ((uart_inst_insttx_fbustx_rd && (!cmd_inst_fbtx_wr))) begin
            cmd_inst_fbtx_full <= 1'b0;
            if ((uart_inst_insttxfifo_addr == 0)) begin
                uart_inst_insttx_fbustx_empty <= 1'b1;
            end
            else begin
                uart_inst_insttxfifo_addr <= (uart_inst_insttxfifo_addr - 1);
            end
        end
        else if ((cmd_inst_fbtx_wr && (!uart_inst_insttx_fbustx_rd))) begin
            uart_inst_insttx_fbustx_empty <= 1'b0;
            if ((!uart_inst_insttx_fbustx_empty)) begin
                uart_inst_insttxfifo_addr <= (uart_inst_insttxfifo_addr + 1);
            end
            if (($signed({1'b0, uart_inst_insttxfifo_addr}) == (4 - 2))) begin
                cmd_inst_fbtx_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: ICESTICK_UART_INST_INSTTXFIFO_GENS_4
    if (cmd_inst_reset == 1) begin
        uart_inst_insttxfifo_nvacant <= 4;
        uart_inst_insttxfifo_ntenant <= 0;
    end
    else begin
        if (uart_inst_insttxfifo_fbus_clear) begin
            uart_inst_insttxfifo_nvacant <= 4;
            uart_inst_insttxfifo_ntenant <= 0;
        end
        else if ((uart_inst_insttx_fbustx_rd && (!cmd_inst_fbtx_wr))) begin
            uart_inst_insttxfifo_nvacant <= (uart_inst_insttxfifo_nvacant + 1);
            uart_inst_insttxfifo_ntenant <= (uart_inst_insttxfifo_ntenant - 1);
        end
        else if ((cmd_inst_fbtx_wr && (!uart_inst_insttx_fbustx_rd))) begin
            uart_inst_insttxfifo_nvacant <= (uart_inst_insttxfifo_nvacant - 1);
            uart_inst_insttxfifo_ntenant <= (uart_inst_insttxfifo_ntenant + 1);
        end
    end
end



assign uart_inst_insttxfifo_fbus_count = uart_inst_insttxfifo_ntenant;


always @(posedge clock) begin: ICESTICK_UART_INST_INSTSYNCTX_RTL
    integer ii;
    uart_inst_instsynctx_staps[0] <= uart_inst_tx;
    for (ii=1; ii<2; ii=ii+1) begin
        uart_inst_instsynctx_staps[ii] <= uart_inst_instsynctx_staps[(ii - 1)];
    end
end



assign uart_tx = uart_inst_instsynctx_staps[(2 - 1)];


always @(posedge clock) begin: ICESTICK_UART_INST_INSTTX_RTLTX
    if (cmd_inst_reset == 1) begin
        uart_inst_insttx_fbustx_rd <= 0;
        uart_inst_insttx_bitcnt <= 0;
        uart_inst_insttx_state <= 3'b000;
        uart_inst_insttx_txbyte <= 0;
        uart_inst_tx <= 1;
    end
    else begin
        uart_inst_insttx_fbustx_rd <= 1'b0;
        case (uart_inst_insttx_state)
            3'b000: begin
                if (((!uart_inst_insttx_fbustx_empty) && uart_inst_baudce)) begin
                    uart_inst_insttx_txbyte <= uart_inst_insttx_fbustx_rdata;
                    uart_inst_insttx_fbustx_rd <= 1'b1;
                    uart_inst_insttx_state <= 3'b001;
                end
            end
            3'b001: begin
                if (uart_inst_baudce) begin
                    uart_inst_insttx_bitcnt <= 0;
                    uart_inst_tx <= 1'b0;
                    uart_inst_insttx_state <= 3'b010;
                end
            end
            3'b010: begin
                if (uart_inst_baudce) begin
                    uart_inst_insttx_bitcnt <= (uart_inst_insttx_bitcnt + 1);
                    uart_inst_tx <= uart_inst_insttx_txbyte[uart_inst_insttx_bitcnt];
                end
                else if ((uart_inst_insttx_bitcnt == 8)) begin
                    uart_inst_insttx_state <= 3'b011;
                    uart_inst_insttx_bitcnt <= 0;
                end
            end
            3'b011: begin
                if (uart_inst_baudce) begin
                    uart_inst_tx <= 1'b1;
                    uart_inst_insttx_state <= 3'b100;
                end
            end
            3'b100: begin
                if (uart_inst_baudce) begin
                    uart_inst_insttx_state <= 3'b000;
                end
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end


always @(posedge clock) begin: ICESTICK_UART_INST_INSTRXFIFO_GENS_0
    integer ii;
    if (uart_inst_instrx_fbusrx_wr) begin
        uart_inst_instrxfifo_mem[0] <= uart_inst_instrx_fbusrx_wdata;
        for (ii=1; ii<4; ii=ii+1) begin
            uart_inst_instrxfifo_mem[ii] <= uart_inst_instrxfifo_mem[(ii - 1)];
        end
    end
end



assign cmd_inst_fbrx_rdata = uart_inst_instrxfifo_mem[uart_inst_instrxfifo_addr];



assign cmd_inst_fbrx_rvld = cmd_inst_fbrx_rd;


always @(posedge clock) begin: ICESTICK_UART_INST_INSTRXFIFO_GENS_3
    if (cmd_inst_reset == 1) begin
        uart_inst_instrxfifo_full <= 0;
        cmd_inst_fbrx_empty <= 1;
        uart_inst_instrxfifo_addr <= 0;
    end
    else begin
        if (uart_inst_instrxfifo_fbus_clear) begin
            uart_inst_instrxfifo_addr <= 0;
            cmd_inst_fbrx_empty <= 1'b1;
            uart_inst_instrxfifo_full <= 1'b0;
        end
        else if ((cmd_inst_fbrx_rd && (!uart_inst_instrx_fbusrx_wr))) begin
            uart_inst_instrxfifo_full <= 1'b0;
            if ((uart_inst_instrxfifo_addr == 0)) begin
                cmd_inst_fbrx_empty <= 1'b1;
            end
            else begin
                uart_inst_instrxfifo_addr <= (uart_inst_instrxfifo_addr - 1);
            end
        end
        else if ((uart_inst_instrx_fbusrx_wr && (!cmd_inst_fbrx_rd))) begin
            cmd_inst_fbrx_empty <= 1'b0;
            if ((!cmd_inst_fbrx_empty)) begin
                uart_inst_instrxfifo_addr <= (uart_inst_instrxfifo_addr + 1);
            end
            if (($signed({1'b0, uart_inst_instrxfifo_addr}) == (4 - 2))) begin
                uart_inst_instrxfifo_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: ICESTICK_UART_INST_INSTRXFIFO_GENS_4
    if (cmd_inst_reset == 1) begin
        uart_inst_instrxfifo_nvacant <= 4;
        uart_inst_instrxfifo_ntenant <= 0;
    end
    else begin
        if (uart_inst_instrxfifo_fbus_clear) begin
            uart_inst_instrxfifo_nvacant <= 4;
            uart_inst_instrxfifo_ntenant <= 0;
        end
        else if ((cmd_inst_fbrx_rd && (!uart_inst_instrx_fbusrx_wr))) begin
            uart_inst_instrxfifo_nvacant <= (uart_inst_instrxfifo_nvacant + 1);
            uart_inst_instrxfifo_ntenant <= (uart_inst_instrxfifo_ntenant - 1);
        end
        else if ((uart_inst_instrx_fbusrx_wr && (!cmd_inst_fbrx_rd))) begin
            uart_inst_instrxfifo_nvacant <= (uart_inst_instrxfifo_nvacant - 1);
            uart_inst_instrxfifo_ntenant <= (uart_inst_instrxfifo_ntenant + 1);
        end
    end
end



assign uart_inst_instrxfifo_fbus_count = uart_inst_instrxfifo_ntenant;


always @(posedge clock) begin: ICESTICK_UART_INST_INSTRX_RTLMID
    uart_inst_instrx_rxd <= uart_inst_rx;
    if (((uart_inst_instrx_rxd && (!uart_inst_rx)) && (uart_inst_instrx_state == 2'b00))) begin
        uart_inst_instrx_mcnt <= 0;
        uart_inst_instrx_rxinprog <= 1'b1;
    end
    else if ((uart_inst_instrx_rxinprog && (uart_inst_instrx_state == 2'b11))) begin
        uart_inst_instrx_rxinprog <= 1'b0;
    end
    else if (uart_inst_baudce16) begin
        uart_inst_instrx_mcnt <= (uart_inst_instrx_mcnt + 1);
    end
    if ((uart_inst_instrx_rxinprog && (uart_inst_instrx_mcnt == 7) && uart_inst_baudce16)) begin
        uart_inst_instrx_midbit <= 1'b1;
    end
    else begin
        uart_inst_instrx_midbit <= 1'b0;
    end
end


always @(posedge clock) begin: ICESTICK_UART_INST_INSTRX_RTLRX
    if (cmd_inst_reset == 1) begin
        uart_inst_instrx_bitcnt <= 0;
        uart_inst_instrx_fbusrx_wdata <= 0;
        uart_inst_instrx_state <= 2'b00;
        uart_inst_instrx_rxbyte <= 0;
        uart_inst_instrx_fbusrx_wr <= 0;
    end
    else begin
        uart_inst_instrx_fbusrx_wr <= 1'b0;
        case (uart_inst_instrx_state)
            2'b00: begin
                if ((uart_inst_instrx_midbit && (!uart_inst_rx))) begin
                    uart_inst_instrx_state <= 2'b01;
                end
            end
            2'b01: begin
                if (uart_inst_instrx_midbit) begin
                    uart_inst_instrx_rxbyte[uart_inst_instrx_bitcnt] <= uart_inst_rx;
                    uart_inst_instrx_bitcnt <= (uart_inst_instrx_bitcnt + 1);
                end
                else if ((uart_inst_instrx_bitcnt == 8)) begin
                    uart_inst_instrx_state <= 2'b10;
                    uart_inst_instrx_bitcnt <= 0;
                end
            end
            2'b10: begin
                if (uart_inst_instrx_midbit) begin
                    uart_inst_instrx_state <= 2'b11;
                    uart_inst_instrx_fbusrx_wr <= 1'b1;
                    uart_inst_instrx_fbusrx_wdata <= uart_inst_instrx_rxbyte;
                end
            end
            2'b11: begin
                uart_inst_instrx_state <= 2'b00;
                uart_inst_instrx_bitcnt <= 0;
            end
        endcase
    end
end


always @(posedge clock) begin: ICESTICK_UART_INST_INSTSYNCRX_RTL
    integer ii;
    uart_inst_instsyncrx_staps[0] <= uart_rx;
    for (ii=1; ii<2; ii=ii+1) begin
        uart_inst_instsyncrx_staps[ii] <= uart_inst_instsyncrx_staps[(ii - 1)];
    end
end



assign uart_inst_rx = uart_inst_instsyncrx_staps[(2 - 1)];


always @(posedge clock) begin: ICESTICK_UART_INST_INSTBAUD_RTLBAUD16
    if (cmd_inst_reset == 1) begin
        uart_inst_instbaud_cnt <= 0;
        uart_inst_baudce16 <= 0;
    end
    else begin
        if ((uart_inst_instbaud_cnt >= 529)) begin
            uart_inst_instbaud_cnt <= (uart_inst_instbaud_cnt - 529);
            uart_inst_baudce16 <= 1'b1;
        end
        else begin
            uart_inst_instbaud_cnt <= (uart_inst_instbaud_cnt + 96);
            uart_inst_baudce16 <= 1'b0;
        end
    end
end


always @(posedge clock) begin: ICESTICK_UART_INST_INSTBAUD_RTLBAUD
    if (cmd_inst_reset == 1) begin
        uart_inst_instbaud_cnt16 <= 0;
        uart_inst_baudce <= 0;
    end
    else begin
        if (uart_inst_baudce16) begin
            uart_inst_instbaud_cnt16 <= (uart_inst_instbaud_cnt16 + 1);
            if ((uart_inst_instbaud_cnt16 == 0)) begin
                uart_inst_baudce <= 1'b1;
            end
            else begin
                uart_inst_baudce <= 1'b0;
            end
        end
        else begin
            uart_inst_baudce <= 1'b0;
        end
    end
end


always @(cmd_inst_ready, cmd_inst_fbrx_empty) begin: ICESTICK_CMD_INST_BEH_FIFO_READ
    if ((cmd_inst_ready && (!cmd_inst_fbrx_empty))) begin
        cmd_inst_fbrx_rd = 1'b1;
    end
    else begin
        cmd_inst_fbrx_rd = 1'b0;
    end
end


always @(posedge clock) begin: ICESTICK_CMD_INST_MMC_INST_BEH_SM
    if (cmd_inst_reset == 1) begin
        cmd_inst_mmc_inst_tocnt <= 0;
        cmd_inst_mmc_inst_state <= 3'b000;
    end
    else begin
        case (cmd_inst_mmc_inst_state)
            3'b000: begin
                if ((!memmap_done)) begin
                    cmd_inst_mmc_inst_state <= 3'b001;
                end
                else if (memmap_write) begin
                    cmd_inst_mmc_inst_state <= 3'b010;
                end
                else if (memmap_read) begin
                    cmd_inst_mmc_inst_state <= 3'b100;
                end
            end
            3'b001: begin
                if (memmap_done) begin
                    cmd_inst_mmc_inst_tocnt <= 0;
                    cmd_inst_mmc_inst_state <= 3'b110;
                end
            end
            3'b010: begin
                cmd_inst_mmc_inst_state <= 3'b110;
                cmd_inst_mmc_inst_tocnt <= 0;
            end
            3'b100: begin
                cmd_inst_mmc_inst_state <= 3'b101;
            end
            3'b101: begin
                if (memmap_done) begin
                    cmd_inst_mmc_inst_state <= 3'b110;
                end
            end
            3'b110: begin
                if ((!(memmap_write || memmap_read))) begin
                    cmd_inst_mmc_inst_state <= 3'b000;
                end
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end


always @(posedge clock) begin: ICESTICK_CMD_INST_BEH_STATE_MACHINE
    integer ii;
    reg [8-1:0] bytecnt;
    integer val;
    integer idx;
    if (cmd_inst_reset == 1) begin
        memmap_read <= 0;
        memmap_write <= 0;
        cmd_inst_bytemon <= 0;
        memmap_mem_addr <= 0;
        memmap_write_data <= 0;
        cmd_inst_packet[0] <= 0;
        cmd_inst_packet[1] <= 0;
        cmd_inst_packet[2] <= 0;
        cmd_inst_packet[3] <= 0;
        cmd_inst_packet[4] <= 0;
        cmd_inst_packet[5] <= 0;
        cmd_inst_packet[6] <= 0;
        cmd_inst_packet[7] <= 0;
        cmd_inst_packet[8] <= 0;
        cmd_inst_packet[9] <= 0;
        cmd_inst_packet[10] <= 0;
        cmd_inst_packet[11] <= 0;
        cmd_inst_fbtx_wr <= 0;
        cmd_inst_state <= 4'b0000;
        cmd_inst_error <= 0;
        cmd_inst_ready <= 0;
        cmd_inst_fbtx_wdata <= 0;
        cmd_inst_bb_per_addr <= 0;
        bytecnt = 0;
    end
    else begin
        case (cmd_inst_state)
            4'b0000: begin
                cmd_inst_state <= 4'b0001;
                cmd_inst_ready <= 1'b1;
                bytecnt = 0;
            end
            4'b0001: begin
                if (cmd_inst_fbrx_rvld) begin
                    for (ii=0; ii<2; ii=ii+1) begin
                        case (ii)
                            0: idx = 0;
                            default: idx = 7;
                        endcase
                        case (ii)
                            0: val = 222;
                            default: val = 202;
                        endcase
                        if (($signed({1'b0, bytecnt}) == idx)) begin
                            if (($signed({1'b0, cmd_inst_fbrx_rdata}) != val)) begin
                                cmd_inst_error <= 1'b1;
                                cmd_inst_state <= 4'b1001;
                            end
                        end
                    end
                    cmd_inst_packet[bytecnt] <= cmd_inst_fbrx_rdata;
                    bytecnt = (bytecnt + 1);
                end
                if ((bytecnt == 12)) begin
                    cmd_inst_ready <= 1'b0;
                    cmd_inst_state <= 4'b0010;
                end
            end
            4'b0010: begin
                cmd_inst_bb_per_addr <= cmd_inst_address[32-1:28];
                memmap_mem_addr <= cmd_inst_address[28-1:0];
                if (memmap_done !== 1) begin
                    $display("*** AssertionError ***");
                end
                bytecnt = 0;
                case (cmd_inst_packet[1])
                    'h1: begin
                        cmd_inst_state <= 4'b0101;
                    end
                    'h2: begin
                        memmap_write_data <= cmd_inst_data;
                        cmd_inst_state <= 4'b0011;
                    end
                    default: begin
                        cmd_inst_error <= 1'b1;
                        cmd_inst_state <= 4'b1001;
                    end
                endcase
            end
            4'b0011: begin
                if (memmap_done) begin
                    memmap_write <= 1'b1;
                    cmd_inst_state <= 4'b0100;
                end
            end
            4'b0100: begin
                memmap_write <= 1'b0;
                if (memmap_done) begin
                    cmd_inst_state <= 4'b0101;
                end
            end
            4'b0101: begin
                if (memmap_done) begin
                    memmap_read <= 1'b1;
                    cmd_inst_state <= 4'b0110;
                end
            end
            4'b0110: begin
                memmap_read <= 1'b0;
                if (memmap_done) begin
                    cmd_inst_packet[(8 + 0)] <= memmap_read_data[32-1:24];
                    cmd_inst_packet[(8 + 1)] <= memmap_read_data[24-1:16];
                    cmd_inst_packet[(8 + 2)] <= memmap_read_data[16-1:8];
                    cmd_inst_packet[(8 + 3)] <= memmap_read_data[8-1:0];
                    cmd_inst_state <= 4'b0111;
                end
            end
            4'b0111: begin
                cmd_inst_fbtx_wr <= 1'b0;
                if ((bytecnt < 12)) begin
                    if ((!cmd_inst_fbtx_full)) begin
                        cmd_inst_fbtx_wr <= 1'b1;
                        cmd_inst_fbtx_wdata <= cmd_inst_packet[bytecnt];
                        bytecnt = (bytecnt + 1);
                    end
                    cmd_inst_state <= 4'b1000;
                end
                else begin
                    cmd_inst_state <= 4'b1010;
                end
            end
            4'b1000: begin
                cmd_inst_fbtx_wr <= 1'b0;
                cmd_inst_state <= 4'b0111;
            end
            4'b1001: begin
                if ((!cmd_inst_fbrx_rvld)) begin
                    cmd_inst_state <= 4'b1010;
                    cmd_inst_ready <= 1'b0;
                end
            end
            4'b1010: begin
                cmd_inst_error <= 1'b0;
                cmd_inst_ready <= 1'b0;
                cmd_inst_state <= 4'b0000;
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
        cmd_inst_bytemon <= bytecnt;
    end
end


always @(posedge clock) begin: ICESTICK_BEH_LED_CONTROL
    memmap_done <= (!(memmap_write || memmap_read));
    if ((memmap_write && (memmap_mem_addr == 32))) begin
        ledreg <= memmap_write_data;
    end
end


always @(memmap_read, memmap_mem_addr, ledreg) begin: ICESTICK_BEH_LED_READ
    if ((memmap_read && (memmap_mem_addr == 32))) begin
        memmap_read_data = ledreg;
    end
    else begin
        memmap_read_data = 0;
    end
end


always @(posedge clock) begin: ICESTICK_BEH_ASSIGN
    if (glbl_tick_sec) begin
        tone <= ((~tone) & 1);
    end
    led <= (ledreg | tone[5-1:0]);
    pmod <= 0;
end

endmodule
